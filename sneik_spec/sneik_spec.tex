% sneik_spec.tex
% 2019-02-11  Markku-Juhani O. Saarinen <mjos@pqshield.com>

\documentclass{iacrtrans}
\usepackage[utf8]{inputenc}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{amsfonts}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{nicefrac}
\usepackage{url}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{color, soul, colortbl}
\usepackage{listings}
\usepackage{pgfplots}
\usepackage{fancyhdr}
\usepackage{datetime}
\usepackage{framed}
\usepackage[savepos]{zref}
\usepackage{booktabs}
\usepackage{pdflscape}

\usepackage{pgfplots, pgfplotstable}
\usetikzlibrary{patterns}

\newif\ifanon
%\anontrue

\DeclareMathOperator{\lcm}{lcm}

\definecolor{xgray}{gray}{0.95}
\definecolor{xhl}{rgb}{1.0,1.0,0.8}
\definecolor{xgreen}{rgb}{0,0.5,0}
\definecolor{xblue}{rgb}{0,0,0.5}
\definecolor{xred}{rgb}{0.5,0,0}

\definecolor{xabar1}{rgb}{0.7, 0.8, 1.0}
\definecolor{xabar2}{rgb}{0.7, 1.0, 1.0}
\definecolor{xabar3}{rgb}{0.7, 1.0, 0.8}

\definecolor{xbbar1}{rgb}{0.8, 1.0, 0.7}
\definecolor{xbbar2}{rgb}{1.0, 0.9, 0.7}

\lstset{ %
	backgroundcolor=\color{xgray},
	basicstyle=\scriptsize\ttfamily,
	breaklines=true,
	captionpos=b,
	frameround=tttt,
	commentstyle=\color{xgreen},
	escapeinside={\%*}{*)},         % if you want to add LaTeX within your code
	keywordstyle=\color{xblue},
	stringstyle=\color{xred},
	frame=single,
	tabsize=4,
%       numbers=left,
%    xleftmargin=7.0ex,
	xleftmargin=5.0ex,
	xrightmargin=5.0ex,
	language=C,
	morekeywords={int32_t, uint8_t, uint16_t, uint32_t, uint64_t}
}


\newcolumntype{x}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{y}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}
\newcolumntype{z}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}p{#1}}

\newcommand{\msf}[1]{\mathsf{#1}}
\newcommand{\mbf}[1]{\mathbf{#1}}
\newcommand{\mcl}[1]{\mathcal{#1}}
\newcommand{\mtt}[1]{\mathtt{#1}}
\newcommand{\hmbf}[1]{\hat{\mathbf{#1}}}

% comment in code
\newcounter{posmarker}
\newcommand{\skiplmargin}[2][0pt]{
	\stepcounter{posmarker}
	\zsavepos{currentloc\theposmarker}
	\hskip\dimexpr-\zposx{currentloc\theposmarker}sp+\zposx{leftmargin}sp+#1\relax #2
	\hskip\dimexpr\zposx{currentloc\theposmarker}sp-\zposx{leftmargin}sp-#1\relax
}
\AtBeginDocument{\zsavepos{leftmargin}}

\newcommand{\rhalf}[1]{\skiplmargin[0.5\textwidth]{\emph{#1}}}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\title[SNEIKEN and SNEIKHA]{SNEIKEN and SNEIKHA}
\subtitle{Authenticated Encryption and Cryptographic Hashing\\
	(Preliminary version of \today)}

	\author{Markku-Juhani O. Saarinen}

	\institute{PQShield Ltd.\\
		Prama House, 267 Banbury Road\\
		Oxford OX2 7HQ, United Kingdom\\
		\email{mjos@pqshield.com}\\
		Tel. +44 (0)7548 620723}

\begin{document}

\maketitle

\keywords{Lightweight Cryptography \and Sponge Modes
	\and SNEIKEN \and SNEIKHA}

\begin{abstract}
	We describe the lightweight SNEIK permutation and two derived sponge
	modes: the SNEIKEN Authenticated Encryption with Associated Data (AEAD) 
	algorithm and the SNEIKHA Cryptographic Hash. The permutation is
	a simple ARX design with very efficient feedback  mixing, optimized for 
	low-end microcontrollers.
	The overall design emphasizes simplicity and ease of integration with
	lightweight cryptographic protocols and post-quantum schemes.
\end{abstract}

\tableofcontents{}

\vfill
\begin{center}
	\includegraphics[height=30pt]{fig/pqshield_colour-crop}

	Copyright $\copyright$ 2019 PQShield Ltd., Oxford UK.
\end{center}

\newpage
\section{Introduction}

	This document describes the SNEIK family of primitives for lightweight 
	cryptography. The primary members of the family are the {\bf SNEIKEN128} 
	AEAD (Authenticated Encryption with Associated Data) algorithm and the 
	{\bf SNEIKHA256} cryptographic hash. SNEIKEN256 and SNEIKHA384 can 
	be paired for higher-security applications. 
	\begin{center}
	\begin{tabular}{l l l l}
		{\bf Name}	& {\bf Type} & {\bf Security} & {\bf Specification}\\
		\hline
		SNEIKEN128 & AEAD & $2^{128}$ & Section \ref{sec:sneiken}.\\
		SNEIKEN256 & AEAD & $2^{256}$ & Section \ref{sec:sneiken}.\\
		{\it SNEIQEN128} & AEAD & 	  & Section \ref{sec:sneiken}.\\
		SNEIKHA256 & HASH & $2^{128}$ & Section \ref{sec:sneikha}.\\
		SNEIKHA384 & HASH & $2^{192}$ & Section \ref{sec:sneikha}.\\
		{\it SNEIGEN128} & XOF  & 	  & Section \ref{sec:sneikha}\\
	\end{tabular}
	\end{center}

	The security for (SNEIKEN) AEADs indicates primarily the effort 
	required to breach the confidentiality of given plaintext, and
	is equivalent to key size. 
	The effort required to breach integrity of ciphertext (i.e. to
	create a forgery) is claimed to be equivalent to size of the 
	ciphertext expansion (authentication tag). Any valid attack must 
	ensure that a nonce does not repeat under the same secret key. 

	For (SNEIKHA) hash functions we primarily indicate effort required to 
	produce collisions on a classical computer. (Second) pre-image attacks
	may require more effort, especially for fixed-format or short messages,
	as used in some hash-based signatures.

	We set no explicit limits on the input sizes (hashed message,
	plaintext, associated data, and the amount of data that can processed 
	under one key), but we assume it to be under $2^{64}$ bits for 
	security analysis.

	The SNEIQEN128 AEAD and SNEIGEN128 XOF are included as ``informational''.
	Even though they have clear use cases in lightweight cryptography, they 
	may not meet the most stringent security criteria for all applications. 
	They but are intended as ``building blocks'' instead; their security must 
	be evaluated in the context where they are used. 

	\paragraph{Shared features between AEAD and Hash.} The SNEIKEN (AEAD) and
	SNEIKHA (hash algorithm) proposals share the underlying SNEIK permutation
	$\msf{f512}^\rho_\delta$ (Section \ref{sec:sneik}), and the BLNK2 padding
	mechanism (Section \ref{sec:blnk}). Therefore implementations of the 
	two algorithms may consist of at least $90\%$ common code.
	
	We note that SNEIK is intended as a full-featured suite that fulfills
	all symmetric cryptographic needs of a lightweight application.
	The BLNK2 modes are based on Author's BLINKER framework for 
	lightweight Sponge-based protocols \cite{DBLP:conf/ctrsa/Saarinen14a}, 
	which has inspired derivative works such Mike Hamburg's lightweight STROBE 
	protocol \cite{DBLP:journals/iacr/Hamburg17}.

	\paragraph{Notation and conventions.} 
	SNEIK is an ARX \cite{DBLP:conf/fse/KhovratovichN10} type construction built
	from three very simple operations on 32-bit words:
	\begin{center}
	\begin{tabular}{r c l}
	A: 	& $x \boxplus y$	
		& Addition modulo word size: $x + y ~ \bmod 2^{32}$. \\
	R: 	& $x \oplus y$	
		& Bitwise exclusive-or operation between $x$ and $y$. \\
	X: 	& $x \lll r$
		& Cyclic left rotation by $r$ bits in 32-bit word. \\
	\end{tabular}
	\end{center}
	We also use Boolean operators $\land$ and $\lor$ to denote 
	bitwise ``and'' and ``or'' operations and vertical $\|$ to denote 
	concatenation of arrays and strings. 

	C-style notation is used for bit and byte arrays;
	vectors are zero-indexed with index in square brackets. 
	We use ranges to indicate subarrays; $v[i \cdots j]$ refers to 
	concatenation of all entries from $v[i]$ to $v[j]$, inclusive.

	All numerical values are stored and exchanged
	in little-endian fashion, with the least significant byte, bit, or vector
	array entry having index 0. Hexadecimal numbers (bytes or words) are 
	prefixed with ``$\mtt{0x}$''. Bit and byte arrays are read from 
	left to right, with index starting with 0. The 32-bit integer 
	$\mtt{0x12345678}$ (decimal 305419896) is therefore stored and 
	transmitted as 4 byte bit vector
	$\mtt{0x78}~\|~\mtt{0x56}~\|~\mtt{0x34}~\|~\mtt{0x12}$.


\section{The SNEIK Permutation}
\label{sec:sneik}

	With $\pi^\rho_\delta$ we denote a family of $\rho$-round 
	permutations on $b$-bit state $\msf{S}$, controlled by a 
	domain identifier $\delta$:
	\begin{equation}
		\label{eqn:f512}
		\msf{S}' = \pi^\rho_\delta(\msf{S}).
	\end{equation}
	Listing \ref{lst:f512} contains a compact C source code 
	implementation of the SNEIK permutation instantiation $\pi = \msf{f512}$
	(with $b=512$) used in our SNEIKEN and SNEIKHA proposals.


\begin{lstlisting}[float, label=lst:f512,
	caption={The SNEIK permutation  
	$\msf{f512}^\rho_\delta(\msf{S})$ in C. We set $\msf{dom} = \delta$
	and $\msf{rounds}=\rho$.}]
// cyclic rotate left for 32-bit words
#define ROL32(x, y) (((x) << (y)) | ((x) >> (32 - (y))))

void sneik_f512(void *s, uint8_t dom, uint8_t rounds)
{
	const uint8_t rc[16] = {						// round constant table
		0xEF, 0xE0, 0xD9, 0xD6, 0xBA, 0xB5, 0x8C, 0x83,
		0x10, 0x1F, 0x26, 0x29, 0x45, 0x4A, 0x73, 0x7C	// (only 8 used now)
	};

	int i, j;										// loop counters
	uint32_t t, *v = (uint32_t *) s;				// assume little endian!

	for (i = 0; i < rounds; i++) {					// loop over rounds
		v[0] ^= (uint32_t) rc[i];					// xor round constant
		v[1] ^= (uint32_t) dom;						// xor domain constant
		for (j = 0; j < 16; j++) {
			t = v[j];								// middle value
			t += v[(j - 1) & 0xF];					// feedback previous
			t = t ^ ROL32(t, 24) ^ ROL32(t, 25); 	// p(x) = x^25 + x^24 + x
			t ^= v[(j - 2) & 0xF];					// outer feedback
			t += v[(j + 2) & 0xF];
			t = t ^ ROL32(t, 9) ^ ROL32(t, 17);		// q(x) = x^17 + x^9 + x
			t ^= v[(j + 1) & 0xF];					// reverse feedback
			v[j] = t;								// store the result
		}
	}
}
\end{lstlisting}	

	\paragraph{Non-linear feedback shift register.}

	Let and $n \geq 5$ be the size of the initial state 
	$\msf{s}[0], \msf{s}[1], \cdots, \msf{s}[n-1]$ in 32-bit words 
	(with $\msf{f512}$ we have $n=16$).
	Recurrence equation \ref{eqn:nflsr} defines	a nonlinear feedback 
	expander sequence $\msf{s}[i]$ for $i \geq n$.
	The seven arithmetic steps $t_j$ are numbered just for referencing
	purposeses.
	\begin{equation}
	\label{eqn:nflsr}
	\begin{split}
	t_1 & = \msf{s}[i-n] \oplus \msf{d}[i]					\\
	t_2 & = t_1 \boxplus \msf{s}[i-1]						\\
	t_3 & = t_2 \oplus (t_2 \lll 24) \oplus (t_2 \lll 25)	\\
	t_4 & = t_3 \oplus   \msf{s}[i-2]						\\
	t_5 & = t_4 \boxplus \msf{s}[i-n+2]						\\
	t_6 & = t_5 \oplus (t_5 \lll 9) \oplus (t_5 \lll 17) 	\\
	t_7 & = t_6 \oplus \msf{s}[i-n+1]						\\
	\msf{s}[i] & = t_7
	\end{split}
	\end{equation}
	The domain separation constant $\msf{d}[i]$ is nonzero 
	only when $i \bmod n \in \{0, 1\}$. We interpret round constants
	to be just an another kind of ``domain separator'', separating rounds 
	from each other. We set $\msf{d}[n*j] = \msf{rc}[j]$ from vector in
	Equation \ref{eqn:mds} and $\msf{d}[n*j + 1] = \delta$.
	The domain identifier value of $\delta$ is set by higher level primitive.
	\begin{equation}
	\label{eqn:mds}
	\begin{split}
	\msf{rc}[0..15] = 
		& \mtt{0xEF, 0xE0, 0xD9, 0xD6, 0xBA, 0xB5, 0x8C, 0x83,} \\
		& \mtt{0x10, 0x1F, 0x26, 0x29, 0x45, 0x4A, 0x73, 0x7C} \\ 
	\end{split}
	\end{equation}

	\paragraph{Round structure.}
	It is easy to see that each step in Equation \ref{eqn:nflsr}
	is invertible. The weight-3 rotation-xor
	operations at steps $t_3$ and $t_6$ can be interpreted as polynomial
	multiplications in the binary polynomial ring 
	$\mathbb{Z}_2[x]/(x^{32}+1)$:
	\begin{align}
		t_3 = p * t_2 ~\bmod ~ x^{32}+1, &~ \text{with} ~ p=x^{25} + x^{24} + 1 \\
		t_6 = q * t_4 ~\bmod ~ x^{32}+1, &~ \text{with} ~ q=x^{17} + x^{9} + 1.
	\end{align}

	The inverse polynomials have Hamming weight 9:
	\begin{align}
	\label{eqn:inverse}
	p * (x^{28} + x^{21} + x^{20} + x^{14} + x^{12} + x^7 + x^6 + x^5 + x^4) 
		& \equiv 1 ~ (\bmod ~ x^{32}+1) \\
	q * (x^{27} + x^{19} + x^{18} + x^{17} + x^{11} + x^9 + x^3 + x^2 + 1)
		& \equiv 1 ~ (\bmod ~ x^{32}+1) 
	\end{align}
	The choice of $p$ and $q$ guarantees that input (differentials) of weight
	less than 6 at $t_2$ and $t_5$ will always have output weight of at 
	least 3 at $t_3$ and $t_6$. Ignoring the nonlinear
	operation at step $t_5$, the composite $p * q$ also has this
	property, but with guaranteed output weight of 4. The coefficients were 
	chosen in a way to allow reasonably efficient implementation on AVR, 
	which only has instructions for single bit shifts of bytes.

	\paragraph{Implementation: ``Sliding window''.}
	Since there are no references beyond $\msf{s}[i-n]$ back in the sequence, 
	the recurrence may be implemented with a static $n$-word table as is
	done in Listing \ref{lst:f512}.
	We may use $\bmod ~ n$ addressing and write $\msf{s}[i - n \pm j]$ as 
	$\msf{s}[i \pm j]$ while $i$ repeatedly scans the values $i = 0, 1, \cdots, 
	n-1$ for each round.

	We see that the operation uses a ``window'' of five inputs to evaluate
	each new value:
	\begin{equation}
		\label{eqn:window}
		\msf{s}[i] = f_{\text{win}}(\msf{s}[i - 2], \msf{s}[i - 1], 
		\msf{s}[i], \msf{s}[i + 1], \msf{s}[i + 2])
	\end{equation}
	Four 32-bit state words can be used to store the $f$ inputs as the
	window moves; the value $\msf{s}[i - 2]$ is used at step 
	$t_4$ before a replacement value $\msf{s}[i + 2]$ is loaded for 
	step $t_5$. 

	The standard implementation method is therefore to unroll
	computation of at least four iterations of Equation \ref{eqn:nflsr}. 
	Table \ref{tab:mcuspeed} gives some implementation metrics for the
	permutation on popular microcontrollers using this implementation method.

	\begin{table}
	\caption{SNEIK permutation performance on 32-bit ARM Cortex M4 
		(NXP/Freescale MK20DX256) and 8-bit AVR (Atmel ATMEGA2560) 
		architectures. The ``RAM'' size is the input/output state +
		stack usage. Cycles per round was measured with
		$\rho=8$. \label{tab:mcuspeed}. 
	}
	\begin{center}
	\begin{tabular}{l l l l l}
		{\bf MCU} & {\bf Unroll} & {\bf RAM} & {\bf ROM} & {\bf Cycles/Round} \\
		\hline
		AVR			& 16-step	 & 64 + 14	& 1974 	& 1078.1 \\
		AVR			& 4-step 	 & 64 + 19	& 618  	& 1126.0 \\
		Cortex M4 	& 16-step 	 & 64 + 16	& 560	& 188.0 \\
		Cortex M4 	& 4-step 	 & 64 + 28	& 232  	& 211.8
	\end{tabular}
	\end{center}
	\end{table}

\newpage
\section{BLNK2 Primitive Sponge Operations}
\label{sec:blnk}

	Our proposals are built from lower-level ``BLINKER-style'' 
	\cite{DBLP:conf/ctrsa/Saarinen14a} primitives. In addition to 
	authenticated encryption and hashing, these primitives can be used to 
	build more complex protocols where two (or more) parties share a 
	single authenticated state. 

	For these modes a tuple $(\msf{S}, i)$ defines the entire state.
	$\msf{S} \in \{0,1\}^b$ is the permutation state and
	$i \in [0, b)$ is a ``next bit'' $\msf{S}[i]$ read/write index to it.
	The primitives may set additional flags on domain parameter
	$\delta$ before passing them to the cryptographic permutation 
	$\pi^\rho_\delta$. This 8-bit domain identifier is constructed from 
	fields given in Table \ref{tab:domsep}.
	\begin{center}
	\begin{tabular}{r l l}
		& $\msf{S.clr}()$ & Clear the state: $\msf{v} \gets 0^b$, $i \gets 0$. \\
		& $\msf{S.fin}(\delta)$ 
			& Mark the end of given domain (Algorithm \ref{alg:fin}).\\
		& $\msf{S.put}(\msf{D}, \delta)$ 
			& Absorb input data $D$ (Algorithm \ref{alg:put}).\\
		& $\msf{D} \gets \msf{S.get}(n, \delta)$
			& Squeeze out $n$ bits into $D$ (Algorithm \ref{alg:get}).\\
		& $\msf{C} \gets \msf{S.enc}(\msf{P}, \delta)$
			& Encrypt plaintext $\msf{P}$ into ciphertext $\msf{C}$ 
				(Algorithm \ref{alg:enc}). \\
		& $\msf{P} \gets \msf{S.dec}(\msf{C}, \delta,)$
			& Decrypt ciphertext $\msf{C}$ into plaintext $\msf{P}$ 
				(Algorithm \ref{alg:dec}).
	\end{tabular}
	\end{center}
	Additionally we have a utility function $\msf{S.inc}(\delta)$
	(Algorithm \ref{alg:inc}) which updates the index $i$ by one and
	invokes the permutation $\pi^\rho_\delta$ if the rate or block is full,
	depending on the $\msf{full}$ bit in the domain indicator $\delta$.

% inc

	\begin{algorithm}
	\caption{Increment index: $\msf{S.inc}(\delta)$.}
	\begin{algorithmic}[1]
	\label{alg:inc}
		\REQUIRE{ Input state $(\msf{S}, i)$, domain $\delta$}
 		\vspace{1ex}
		\STATE{$i \gets i + 1$}
			\rhalf{Increment index.}
		\IF{($\delta \land \msf{full} = 0$ and $i = r$) or \\
		~~  ($\delta \land \msf{full} = \msf{full}$ and $i = b$)}	
			\STATE{$\msf{S} \gets \pi^\rho_\delta(\msf{S})$}
				\rhalf{Apply permutation if rate or block is full.}
			\STATE{$i \gets 0$}
				\rhalf{Reset index.}
		\ENDIF
 		\vspace{1ex}
		\ENSURE{ Updated state $(\msf{S}, i)$. }
	\end{algorithmic}
	\end{algorithm}

% fin

	\begin{algorithm}
	\caption{End a data element (padding): $\msf{S.fin}(\delta)$.}
	\begin{algorithmic}[1]
	\label{alg:fin}
		\REQUIRE{ Input state $(\msf{S}, i)$, domain $\delta$}
 		\vspace{1ex}
		\STATE{$\msf{S}[i] \gets \msf{S}[i] \oplus 1$}
			\rhalf{Add padding bit, typically byte $\mtt{0x01}$.}
		\IF{$\delta \land \msf{full} = 0$}
			\STATE{$\msf{S}[r-1] \gets \msf{S}[r-1] \oplus 1$}			
				\rhalf{Normal capacity; last rate byte gets $\mtt{0x80}.$}
		\ENDIF
		\STATE{$\msf{S} \gets \pi^\rho_{(\delta ~\lor~ \msf{last})}(\msf{S})$}
			\rhalf{Permutation with domain end marker $\msf{last}$.}
		\STATE{$i \gets 0$}
			\rhalf{Reset index.}	
 		\vspace{1ex}
		\ENSURE{ Updated state $\msf{S}$. }
	\end{algorithmic}
	\end{algorithm}

% put

	\begin{algorithm}
	\caption{Absorb data: $\msf{S.put}(\msf{D}, \delta)$.}
	\begin{algorithmic}[1]
	\label{alg:put}
		\REQUIRE{ Input state $(\msf{S}, i)$, 
			data $\msf{D} \in \{0,1\}^{*}$,
			domain $\delta$.}
 		\vspace{1ex}

		\FOR {$j=0, 1, .., \msf{length(D)} - 1$}
			\STATE{$\msf{S}[i] \gets \msf{S}[i] \oplus \msf{D}[j]$}
				\rhalf{Add (xor) input data to the state.}
			\STATE{$\msf{S.inc}(\delta)$}
				\rhalf{Increment index $i$.}
		\ENDFOR
		\ENSURE{ Updated state $(\msf{S}, i)$. }
	\end{algorithmic}
	\end{algorithm}

% get

	\begin{algorithm}
	\caption{Squeeze data: $\msf{D} = \msf{S.get}(n, \delta)$.}
	\begin{algorithmic}[1]
	\label{alg:get}
		\REQUIRE{ Input state $(\msf{S}, i)$, 
			length of output $n$,
			domain $\delta$.}
 		\vspace{1ex}
		\STATE{$\msf{D}=\{\}$}
			\rhalf{Empty string.}	
		\FOR {$j=0, 1, .., n - 1$}
			\STATE{$\msf{D}[j] \gets \msf{S}[i]$}
				\rhalf{Get a bit from the state.}
			\STATE{$\msf{S.inc}(\delta)$}
				\rhalf{Increment index $i$.}
		\ENDFOR
		\ENSURE{ Output data $\msf{D}$, updated state $(\msf{S}, i)$. }
	\end{algorithmic}
	\end{algorithm}

% enc

	\begin{algorithm}
	\caption{Encrypt data: $\msf{C} = \msf{S.enc}(\msf{P}, \delta)$.}
	\begin{algorithmic}[1]
	\label{alg:enc}
		\REQUIRE{ Input state $(\msf{S}, i)$, 
			plaintext $\msf{P}$,
			domain $\delta$.}
 		\vspace{1ex}
		\STATE{$\msf{C}=\{\}$}
			\rhalf{Empty ciphertext.}	
		\FOR {$j=0, 1, .., \msf{length}(n)(\msf{P}) - 1$}
			\STATE{$\msf{C}[j] \gets \msf{S}[i] \oplus \msf{P}[j]$}
				\rhalf{Xor plaintext with the state.}
			\STATE{$\msf{S}[i] \gets C[j]$}
				\rhalf{Ciphertext goes into the state.}
			\STATE{$\msf{S.inc}(\delta)$}
				\rhalf{Increment index $i$.}
		\ENDFOR
		\ENSURE{ Ciphertext $\msf{C}$, updated state $(\msf{S}, i)$. }
	\end{algorithmic}
	\end{algorithm}

% dec

	\begin{algorithm}
	\caption{Decrypt data: $\msf{P} = \msf{S.dec}(\msf{C}, \delta)$.}
	\begin{algorithmic}[1]
	\label{alg:dec}
		\REQUIRE{ Input state $(\msf{S}, i)$, 
			ciphertext $\msf{C}$,
			domain $\delta$.}
 		\vspace{1ex}
		\STATE{$\msf{P}=\{\}$}
			\rhalf{Empty plaintext.}	
		\FOR {$j=0, 1, .., \msf{length}(n)(\msf{P}) - 1$}
			\STATE{$\msf{P}[j] \gets \msf{S}[i] \oplus \msf{C}[j]$}
				\rhalf{Xor ciphertext with the state.}
			\STATE{$\msf{S}[i] \gets C[j]$}
				\rhalf{Ciphertext goes into the state.}
			\STATE{$\msf{S.inc}(\delta)$}
				\rhalf{Increment index $i$.}
		\ENDFOR
		\ENSURE{ Plaintext $\msf{P}$, updated state $(\msf{S}, i)$. }
	\end{algorithmic}
	\end{algorithm}

% domain specifiers 

	\begin{table}
	\caption{Domain indicator $\delta$ bits and fields. Not all are used
		in current proposals.	\label{tab:domsep}}
	\begin{center}
	\begin{tabular}{c c l l}
	{\bf Name}	 & {\bf Value} 	& {\bf Class} & {\bf Purpose} \\
	\hline
	$\msf{last}$ & $\mtt{0x01}$	& Flag & 
		Final (padded) block marker. \\
	$\msf{full}$ & $\mtt{0x02}$ & Flag & 
		Full state indicator. \\
	$\msf{ad}$	 & $\mtt{0x10}$	& Input & 
		Authenticated Data / Hash input. \\
	$\msf{adf}$	 & $\mtt{0x12}$	& Input & 
		Full-state AAD ($\msf{adf} = \msf{ad} \lor \msf{full}$). \\
	$\msf{keyf}$ & $\mtt{0x22}$	& Input &
		Initialization block 
		($\msf{keyf} = \msf{key} \lor \msf{full}$).	\\
	$\msf{hash}$ & $\mtt{0x40}$	& Output &
		Hash, MAC, or XOF. \\
	$\msf{ptct}$ & $\mtt{0x70}$	& In/out &
		Plaintext/ciphertext duplex block. \\
	\\
	\multicolumn{4}{l}{\bf Not (directly) used in these proposals:} \\
	$\msf{a2b}$	 & $\mtt{0x04}$	& Proto & 
		Originator: Alice.	\\
	$\msf{b2a}$	 & $\mtt{0x08}$	& Proto & 
		Originator: Bob.	\\
	$\msf{key}$	 & $\mtt{0x20}$	& Input &
		Secret key material. \\
	$\msf{bit7}$ & $\mtt{0x80}$	& & \emph{Reserved.}
	\end{tabular}
	\end{center}

	\end{table}

\section{The SNEIKEN Authenticated Encryption Algorithm}
\label{sec:sneiken}

	The SNEIKEN family of authenticated encryption with associated data (AEAD) 
	algorithms are characterized by six bit string variables:
	\begin{center}
	\begin{tabular}{c l l}
		{\bf Var} & {\bf Description} & {\bf Length} \\
		\hline
		$K$ & Secret key			& Fixed $k$	\\
		$N$ & Nonce or IV			& Fixed $n$	\\
		$A$ & Associated data		& Any $a$ \\
		$P$ & Plaintext				& Any $p$ \\
		$T$ & Authentication tag	& Fixed $t$ \\
		$C$ & Ciphertext			& $c=p+t$ \\
	\end{tabular}
	\end{center}
	The algorithms aim to provide integrity and confidentiality protection
	for $P$ and $C$ but only integrity protection for $A$. Generally
	speaking the confidentiality should be at $k$-bit security level and
	integrity at $t$-bit level (this may not hold for SNEIQEN128 in all
	attack models, however.) SNEIKEN128 is the primary member of the family:
	\begin{center}
	\begin{tabular}{x{25mm} x{15mm}  x{15mm} x{15mm} x{15mm} x{15mm}}
		{\bf Name} & {\bf Rate} & {\bf Rounds} & {\bf Key} & {\bf Nonce} 
			& {\bf Tag}  \\
		\hline
		SNEIKEN128 & $r=384$ & $\rho=6$ & $k=128$ & $n=128$ & $t=128$ \\
		SNEIKEN256 & $r=256$ & $\rho=8$ & $k=256$ & $n=128$ & $t=128$ \\
		SNEIQEN128 & $r=384$ & $\rho=4$ & $k=128$ & $n=96$  & $t=128$ \\
	\end{tabular}
	\end{center}

	\paragraph{Encryption and decryption.}
	We define a 6-byte ``variant identifier block'' as follows:
	\begin{equation}
		\msf{ID}[0..5] = \mtt{0x61}, \mtt{0x65}, 
			r / 8, k / 8, n / 8, t / 8
	\end{equation}
	The first two bytes are ASCII '{\tt a}' and '{\tt e}', followed
	by byte lengths for rate, key, nonce, and tag. 
	We denote the encryption process by $C \gets \msf{SNEIKEN}(K, N, A, P)$.
	Algorithm \ref{alg:aead} contains the full procedure for $\msf{SNEIKEN}$ using 
	the BLNK primitives defined in Section \ref{sec:blnk}.

	\begin{algorithm}
	\caption{Authenticated encryption $C \gets \msf{SNEIKEN}(K, N, A, P)$.}
	\label{alg:aead}
	\begin{algorithmic}[1]
		\REQUIRE{	Secret key $K$, (public) nonce $N$, 
					associated data $A$, and plaintext $P$.}
		\vspace{1ex}
		\STATE{$\msf{S.clr()}$}
			\rhalf{Initialize the state: $\msf{S}=0^b, i=0$}
		\STATE{$\msf{S.put}( \msf{ID}~\|~K~\|~N,~\msf{keyf} )$}
			\rhalf{Identifier, secret key, and nonce.}
		\STATE{$\msf{S.fin}( \msf{keyf} )$}
			\rhalf{Pad and permute the key block.}

		\STATE{$\msf{S.put}( A,~\msf{adf} )$}
			\rhalf{Associated authenticated data.}
		\STATE{$\msf{S.fin}( \msf{adf} )$}
			\rhalf{Pad and permute, even if $a=0$.}
		\STATE{$C' \gets \msf{S.enc}(P, \msf{ptct})$}
			\rhalf{Actual ciphertext.}
		\STATE{$\msf{S.fin}( \msf{ptct} )$}
			\rhalf{Pad and permute, even if $p=0$.}
		\STATE{$T \gets \msf{S.get}(t, \msf{hash})$}
			\rhalf{Authentication tag, $t$ bits.}
		\STATE{$C \gets C'~\|~T$}
			\rhalf{Authenticated ciphertext.}
		\vspace{1ex}
		\ENSURE{ Ciphertext $C$. }
	\end{algorithmic}
	\end{algorithm}

	\noindent
	Algorithm \ref{alg:aeadinv} specifies the corresponding  
	decryption and authentication function
	\begin{equation}
		\{P, \msf{FAIL} \} \gets \msf{SNEIKEN}^{-1}(K, N, A, C).
	\end{equation}
	Decryption must output only $\msf{FAIL}$
	upon integrity check failure (no partial plaintext!)

	\begin{algorithm}
	\caption{Authenticated decryption 
		$\{P, \msf{fail}\} \gets \msf{SNEIKEN}^{-1}(K, N, A, C)$.}
	\label{alg:aeadinv}
	\begin{algorithmic}[1]
		\REQUIRE{	Secret key $K$, (public) nonce $N$, 
					associated data $A$, and ciphertext $C$.}
		\vspace{1ex}
		\STATE{$\msf{S.clr}()$}
			\rhalf{Initialize the state: $\msf{S}=0^b, i=0$}
		\STATE{$\msf{S.put}( \msf{ID}~\|~K~\|~N,~\msf{keyf} )$}
			\rhalf{Identifier, secret key, and nonce.}
		\STATE{$\msf{S.fin}( \msf{keyf} )$}
			\rhalf{Pad and permute the key block.}
		\STATE{$\msf{S.put}( A,~\msf{adf} )$}
			\rhalf{Associated authenticated data.}
		\STATE{$\msf{S.fin}( \msf{adf} )$}
			\rhalf{Pad and permute, even if $a=0$.}
		\STATE{$P \gets \msf{S.dec}(C[0 \cdots c-t-1], \msf{ptct})$}
			\rhalf{Decrypt plaintext from first $c-t$ bits of $C$.}
		\STATE{$\msf{S.fin}( \msf{ptct} )$}
			\rhalf{Pad and permute, even if $p=0$.}
		\STATE{$T = \msf{S.get}(t, \msf{hash})$}
			\rhalf{Authentication tag, $t$ bits.}

		\IF{$T = C[c-t \cdots c-1]$}
			\RETURN{$P$}
				\rhalf{Last $t$ bits of $C$ matches with tag $T$.}
		\ELSE
			\RETURN{$\msf{FAIL}$}
				\rhalf{Authentication failure.}
		\ENDIF
		\vspace{1ex}
		\ENSURE{ Plaintext $P$ or $\msf{FAIL}$. }
	\end{algorithmic}
	\end{algorithm}

	\paragraph{MAC-and-continue in lightweight setting.}
	Lightweight protocols can avoid per-message rekeying by 
	padding the MAC with $\msf{S.fin}( \msf{hash} )$, and then directly 
	continuing to process the next message (From step 4 in Algorithm 
	\ref{alg:aead}). The decryption side must of course do the same. This is 
	not only a significant speedup but also saves memory and provides
	``forward security'' since there is no longer any need to retain the original 
	secret key or nonce.

	\paragraph{SNEIQEN Use Cases.}
	The 4-round SNEIQEN may not be suitable as universally as the main
	SNEIKEN algorithms. It is intended for applications where attacker has
	only a limited ability to perform chosen plaintext- or ciphertext 
	queries -- which is often the case with low-bandwidth lightweight devices.
	The suitability of SNEIQEN must therefore be evaluated individually for
	each application.

	

\section{The SNEIKHA Cryptographic Hash}
\label{sec:sneikha}

	The SNEIKHA family of hash functions produce a $h$-bit hash $H$ from 
	input $A$ with arbitrary bit length $a$. The security against 
	collision search for SNEIKHA algorithms is expected to be 
	$2^{\frac{b-r}{2}}$ -- which is equivalent to $2^{h/2}$ for these 
	fixed-length hashes. Complexity of (second) pre-image search can be higher 
	for format-restricted inputs.
	SNEIKHA256 is the primary member of the family:
	\begin{center}
	\begin{tabular}{x{25mm} x{15mm} x{15mm} x{15mm}}
		{\bf Name} & {\bf Hash} & {\bf Rate} & {\bf Rounds} \\
		\hline
		SNEIKHA256 & $h=256$  & $r=256$ & $\rho=8$ \\
		SNEIKHA384 & $h=384$  & $r=128$ & $\rho=8$ \\
		{\it SNEIGEN128} & $h=$ any & $r=384$ & $\rho=4$ \\
	\end{tabular}
	\end{center}

	Algorithm \ref{alg:hash} specifies SNEIKHA using the BLNK primitives
	of Section \ref{sec:blnk}. We note that if the squeezing step
	$\msf{S.get}()$ is implemented literally (as in Algorithm \ref{alg:get}),
	there will be a final permutation call which is unnecessary if SNEIKHA
	is not used as part of some intermediate-hash scheme. This is because
	internally the SNEIKHA algorithms are really extensible-output 
	functions (XOFs). We may define explicit XOF padding modes
	in the future if a need arises to distinguish XOF use cases from hashes.

	\begin{algorithm}
	\caption{Cryptographic hash $H \gets \msf{SNEIKHA}(A)$.}
	\label{alg:hash}
	\begin{algorithmic}[1]
		\REQUIRE{	Data to be hashed $A$.}
		\vspace{1ex}
		\STATE{$\msf{S.clr()}$}
			\rhalf{Initialize the state: $\msf{S}=0^b, i=0$}
		\STATE{$\msf{S.put}( A,~\msf{adf} )$}
			\rhalf{Absorb input data.}
		\STATE{$A \gets \msf{S.get}(h, \msf{hash})$}
			\rhalf{Squeeze hash, $h$ bits.}
		\vspace{1ex}
		\ENSURE{ Hash $H$ of $A$. }
	\end{algorithmic}
	\end{algorithm}

	\paragraph{SNEIGEN Use Cases.}
	We are also including SNEIGEN, which is really not a hash function 
	but a seed expander with limited cryptographic strength. It is intended 
	for cryptographic applications that need ``random-like stuffing''.
	One such example is the padding in PKCS \#1 
	\cite{DBLP:journals/rfc/rfc8017}. 
	An another example is the expansion
	of a short seed into public value $\mbf{A}$ in many lattice-based 
	public key algorithms, including Round5 \cite{2019BaBhFl+}. The authors
	of \cite{DBLP:journals/iacr/BosFMOS18a} argue that ``good statistical
	properties'' are sufficient for the public matrix $\mbf{A}$ in a 
	lightweight implementation of the Frodo PQC encryption algorithm.	

	\paragraph{Random Number Generation}
	If the SNEIK permutation is used to build a general-purpose random 
	number generator, this would also be called ``SNEIGEN''. New randomness 
	can be added at any point with $\msf{S.put()}$. If cryptographic
	security is required from the generator, we suggest increasing the
	number of rounds to $\rho = 8$ and limiting rate to $r \leq b/2$.

	\paragraph{Implementation and performance.}
	Compiling \verb|hash.c| implementing the NIST hash API is 288 bytes on AVR
	and 180 bytes on Cortex-M4.

	\paragraph{Implementation and performance.}
	Compiling \verb|encrypt.c| that implements the NIST AEAD API (for 
	Encryption and Decryption) is 1100 bytes on AVR and 626 bytes on Cortex-M4.


\section{Design Rationale}

	\paragraph{Design goals.}
	Our main design goal was to create fast permutation-based primitives
	suitable for prominent 8, 16, and 32-bit embedded microcontrollers -- 
	primarily ARM Cortex-M and Atmel AVR families. The 32-bit Cortex-M 
	target directly led to the use of a 32-bit primary datapath, while AVR 
	limited the use of rotations (which are essentially ``free'' in Cortex 
	M3/4). It was clear that the entire permutation state would not fit into
	the register file of either of these targets, so processing would
	have to be ``localized'' to some degree. This lead to the ``window''
	design of Equation \ref{eqn:window}.

	\paragraph{Embracing the sequential.}
	Since multiple-issue or superscalar processing is generally not available
	on lightweight targets, instruction and data path parallelism is 
	not a great concern. Indeed, we decided to go an opposite route and
	maximize the critical path instead of minimizing it. 
	As a result, we can use immediate feedback from one processed 
	word to the next, which helps to diffuse the state extremely rapidly.
	The design achieves complete avalanche (each input bit affecting
	each output bit) in only two rounds.
	
	The permutation design is clearly influenced by a large number of 
	previous proposals, starting with the ``Block TEA'' algorithm by Wheeler 
	and Needham, which the author cryptanalyzed more than two decades ago 
	\cite{xxtea}. 

	\paragraph{Sponge modes.}
	The BLNK2 modes are based on Author's BLINKER framework for 
	lightweight Sponge-based protocols \cite{DBLP:conf/ctrsa/Saarinen14a}, 
	which has inspired derivative works such Mike Hamburg's STROBE 
	\cite{DBLP:journals/iacr/Hamburg17}. The mode implementation is derived
	from the one used for CBEAM \cite{DBLP:conf/ctrsa/Saarinen14} and 
	WHIRLBOB \cite{DBLP:conf/nordsec/SaarinenB15} proposals.

	We use an updated variant with a full-state keying mechanism and
	also a full-state keyed sponge method for associated data 
	\cite{DBLP:conf/crypto/GaziPT15,DBLP:conf/asiacrypt/MenninkRV15}.
	This full-state use case motivated us to move domain separation 
	from capacity to be an ``out-of-band'' parameter of the cryptographic 
	permutation itself.
	Otherwise the capacity matches the intended security level, as 
	discussed in \cite{DBLP:conf/asiacrypt/JovanovicLM14}.


% == BIBLIOGRAPHY ==

\bibliographystyle{alphaurl}
\bibliography{sneik_spec}

\end{document}
